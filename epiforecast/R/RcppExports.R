# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

CartesianProductCurves <- function(fit_obj_rcpp, y_scale_baseline, curve_index_choices, peak_time_choices, x_shift_choices, x_scale_choices, sd_choices, sd_scale_choices, peak_height_choices, y_scale_choices) {
    .Call('_epiforecast_CartesianProductCurves', PACKAGE = 'epiforecast', fit_obj_rcpp, y_scale_baseline, curve_index_choices, peak_time_choices, x_shift_choices, x_scale_choices, sd_choices, sd_scale_choices, peak_height_choices, y_scale_choices)
}

CartesianProductLogWeights <- function(new_dat_df, dat_rcpp, observed_past_shrinkage_map_df, reasonable_future_shrinkage_map_df, n_future_neighbors, fit_obj_rcpp, y_scale_baseline, curve_index_choices, peak_time_choices, x_shift_choices, x_scale_choices, sd_choices, sd_scale_choices, peak_height_choices, y_scale_choices, bias_peaktime_mean, bias_peaktime_sd, bias_peaktime_shrinkage, bias_peakheight_mean, bias_peakheight_sd, bias_peakheight_shrinkage) {
    .Call('_epiforecast_CartesianProductLogWeights', PACKAGE = 'epiforecast', new_dat_df, dat_rcpp, observed_past_shrinkage_map_df, reasonable_future_shrinkage_map_df, n_future_neighbors, fit_obj_rcpp, y_scale_baseline, curve_index_choices, peak_time_choices, x_shift_choices, x_scale_choices, sd_choices, sd_scale_choices, peak_height_choices, y_scale_choices, bias_peaktime_mean, bias_peaktime_sd, bias_peaktime_shrinkage, bias_peakheight_mean, bias_peakheight_sd, bias_peakheight_shrinkage)
}

ZipProductCurvesAndLogWeightsp <- function(output_times, new_dat_df, dat_rcpp, observed_past_shrinkage_map_df, reasonable_future_shrinkage_map_df, n_future_neighbors, fit_obj_rcpp, y_scale_baseline, curve_index_choices, peak_time_choices, x_shift_choices, x_scale_choices, sd_choices, sd_scale_choices, peak_height_choices, y_scale_choices, bias_peaktime_mean, bias_peaktime_sd, bias_peaktime_shrinkage, bias_peakheight_mean, bias_peakheight_sd, bias_peakheight_shrinkage) {
    .Call('_epiforecast_ZipProductCurvesAndLogWeightsp', PACKAGE = 'epiforecast', output_times, new_dat_df, dat_rcpp, observed_past_shrinkage_map_df, reasonable_future_shrinkage_map_df, n_future_neighbors, fit_obj_rcpp, y_scale_baseline, curve_index_choices, peak_time_choices, x_shift_choices, x_scale_choices, sd_choices, sd_scale_choices, peak_height_choices, y_scale_choices, bias_peaktime_mean, bias_peaktime_sd, bias_peaktime_shrinkage, bias_peakheight_mean, bias_peakheight_sd, bias_peakheight_shrinkage)
}

#' Weighted, more \code{nbins}-restrictive version of \code{base::tabulate}
#'
#' @param bin integer-compatible vector; entries must be non-NA and between 1
#' and \code{nbins}; these indices denote entries in the result vector to which
#' the corresponding weights in \code{w} should be added
#' @param nbins single non-NA, non-negative integer; length of the vector to
#' return
#' @param w numeric-compatible vector of the same length as \code{bin}; weights
#' corresponding to the indices in \code{bin}
#' @return numeric vector of length \code{nbins}; the \code{i}th entry is like
#' \code{sum(w[bin==i])}, but with a naive summation algorithm
#'
#' @export
weighted_tabulate <- function(bin, nbins, w) {
    .Call('_epiforecast_WeightedTabulateRcpp', PACKAGE = 'epiforecast', bin, nbins, w)
}

